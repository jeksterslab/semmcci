---
title: "Example 2: The Serial Mediation Model"
author: "Ivan Jacob Agaloos Pesigan"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Example 2: The Serial Mediation Model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This is an example of a serial mediation model with two mediators
where `X` is the predictor, `M1` is the first mediator, `M2` is the second mediator,
and `Y` is the dependent variable.

```{tikz, model, echo = FALSE, fig.cap = "The Serial Mediation Model", fig.ext = 'png', cache = FALSE}
\usetikzlibrary{
	er,
	arrows,
	positioning
}

\begin{tikzpicture}[
		auto,
		node distance = 20mm,
		manifest/.style = {
			rectangle,
			draw,
			thick,
			inner sep = 0pt,
			minimum width = 15mm,
			minimum height = 10mm
		},
		inv/.style = {
			rectangle,
			draw=none,
			fill=none,
			inner sep = 0pt,
			minimum width = 15mm,
			minimum height = 10mm
		},
		error/.style = {
			ellipse,
			draw,
			thick,
			inner sep = 0pt,
			minimum size = 7mm,
			align = center
		},
		mean/.style={
			regular polygon,
			regular polygon sides = 3,
			draw,
			thick,
			inner sep = 0pt,
			minimum width = 7mm,
			minimum height = 7mm
		},
		path/.style = {
			->,
			thick,
			>=stealth'
		},
		cov/.style = {
			<->,
			thick,
			>=stealth'
		},
	]
	\node[manifest] (X) {$X$};
	\node[manifest] (M1) [above right = of X] {$M_{1}$};
	\node[manifest] (M2) [right = of M1] {$M_{2}$};
	\node[manifest] (Y) [below right = of M2] {$Y$};
	\node[error] (eM1) [above = of M1] {$e_{M_{1}}$};
	\node[error] (eM2) [above = of M2] {$e_{M_{2}}$};
	\node[error] (eY) [above = of Y] {$e_{Y}$};
	\draw[path] (M1) to node[above] {$\delta$} (M2);
	\draw[path] (M1) to node[above] {$\beta_{1}$} (Y);
	\draw[path] (M2) to node[above] {$\beta_{2}$} (Y);
	\draw[path] (X) to node {$\tau^{\prime}$} (Y);
	\draw[path] (X) to node {$\alpha_{1}$} (M1);
	\draw[path] (X) to node {$\alpha_{2}$} (M2);
	\draw[path] (eM1) to node {$1$} (M1);
	\draw[path] (eM2) to node {$1$} (M2);
	\draw[path] (eY) to node {$1$} (Y);
	\draw[cov] (X) to[out = 70, in = 110, looseness = 5] node[above] {$s_{X}^{2}$} (X);
	\draw[cov] (eM1) to[out = -290, in = -250, looseness = 5] node[above] {$s^{2}_{e_{M_{1}}}$} (eM1);
	\draw[cov] (eM2) to[out = -290, in = -250, looseness = 5] node[above] {$s^{2}_{e_{M_{2}}}$} (eM2);
	\draw[cov] (eY) to[out = -290, in = -250, looseness = 5] node[above] {$s^{2}_{e_{Y}}$} (eY);
\end{tikzpicture}
```

```{r, message = FALSE}
library(semmcci)
library(lavaan)
```

## Data

```{r}
n <- 1000
X <- rnorm(n = n)
M1 <- 0.50 * X + rnorm(n = n)
M2 <- 0.15 * X + 0.50 * M1 + rnorm(n = n)
Y <- 0.10 * X + 0.05 * M1 + 0.50 * M2 + rnorm(n = n)
data <- data.frame(X, M1, M2, Y)
```

## Model Specification

We can define several indirect effects in this example:

  - $X \rightarrow M1 \rightarrow M2 \rightarrow Y$
  - $X \rightarrow M1 \rightarrow M2$
  - $X \rightarrow M1 \rightarrow Y$
  - $M1 \rightarrow M2 \rightarrow Y$

These indirect effects are defined using the `:=` operator
in the `lavaan` model syntax.

```{r}
model <- "
  Y ~ cp * X + b1 * M1 + b2 * M2
  M2 ~ a2 * X + k * M1
  M1 ~ a1 * X
  # X -> M1 -> M2 -> Y
  a1kb2 := a1 * k * b2
  # X -> M1 -> M2
  a1k := a1 * k
  # X -> M1 -> Y
  a2b2 := a2 * b2
  # M1 -> M2 -> Y
  kb2 := k * b2
"
```

## Model Fitting

```{r}
fit <- sem(data = data, model = model)
```

## Monte Carlo Confidence Intervals

The `fit` `lavaan` object can then be passed to the `MC()` function from `semmcci`
to generate Monte Carlo confidence intervals.

```{r}
MC(fit, R = 20000L, alpha = c(0.001, 0.01, 0.05))
```

## Standardized Monte Carlo Confidence Intervals

Standardized Monte Carlo Confidence intervals can be generated by passing the result of the `MC()` function to `MCStd()`.

> **Note:** We recommend setting `fixed.x = FALSE` when generating standardized estimates and confidence intervals to model the variance of the predictor/s.

```{r}
fit <- sem(data = data, model = model, fixed.x = FALSE)
unstd <- MC(fit, R = 20000L, alpha = c(0.001, 0.01, 0.05))
MCStd(unstd)
```
